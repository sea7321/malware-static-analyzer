"""
File: static_analyzer.py
Description: Main module that statically analyzes exe files.
Author: Savannah Alfaro, sea2985
"""

# Standard Imports
import argparse
import logging

# Third-Party Imports
from colorama import init
from termcolor import colored

# Local Imports
import functions


def get_file_properties(filename):
    """
    Retrieves basic file properties from a portable executable file including
    creation and modification dates, file size, and file hashes.
    :param filename: the portable executable filename
    :return: None
    """
    # variables
    file_creation_date = functions.get_file_creation_date(filename)
    file_modification_date = functions.get_file_modification_date(filename)
    file_size = functions.get_file_size(filename)

    print("[*] Retrieving file properties...")
    print("\tFile Creation Date: " + file_creation_date)
    print("\tFile Modification Date: " + file_modification_date)
    print("\tFile Size: {} bytes".format(file_size))

    # variables
    md5_hash = functions.get_md5_hash(filename)
    sha1_hash = functions.get_sha1_hash(filename)
    sha256_hash = functions.get_sha256_hash(filename)

    print("\n[*] Retrieving file hashes...")
    print("\tMD5 Hash: " + md5_hash)
    print("\tSHA1 Hash: " + sha1_hash)
    print("\tSHA256 Hash: " + sha256_hash)


def check_suspicious_activity(filename):
    """
    Checks for suspicious activity within the file such as
    function calls or dll functions.
    :param filename: the portable executable filename
    :return:
    """
    # variables
    dll_functions = functions.get_dll_functions(filename)
    function_calls = functions.get_function_calls(filename)[0]
    suspicious_function_calls = functions.get_function_calls(filename)[1]

    # list all imported DLLs
    print("\n[*] Listing imported DLLs...")
    if dll_functions:
        for function in dll_functions:
            print("\t{}".format(function))
    else:
        print("\tNo imported DLLs")

    # list function calls
    print("\n[*] Listing function calls...")
    if function_calls:
        for function_call in function_calls:
            # check for suspicious function calls
            if function_call in suspicious_function_calls:
                print(colored("\t{}".format(function_call), "yellow"))
            else:
                print("\t{}".format(function_call))
    else:
        print("\tNo function calls")

    # print number of suspicious function calls
    if suspicious_function_calls:
        print(colored("\n\tFound {} suspicious function calls".format(len(suspicious_function_calls)), "yellow"))
    else:
        print(colored("\n\tNo suspicious function calls found", "green"))


def check_anti_virtual(filename):
    """
    Checks for anti-virtualization features within the file such as
    if it is packed or is checking for debug functions.
    :param filename: the portable executable filename
    :return: None
    """
    print("\n[*] Checking for anti-virtualization features...")

    # check for malware packers
    packed = functions.is_packed(filename)
    print("\tPacked: {}".format(packed))

    # check for anti-debug functions
    anti_debug_functions = functions.get_anti_debug_functions(filename)
    if anti_debug_functions:
        print("\tAnti-Debug Functions: {}".format(len(anti_debug_functions)))
    else:
        print("\tAnti-Debug Functions: None")


def yara_checks(filename):
    """
    Uses Yara rules to check for cryptographic algorithms, malware packers,
    and anti-debug/anti-virtualization functions within the file.
    :param filename: the portable executable filename
    :return: None
    """
    # check for cryptographic algorithms
    print("\n[*] Checking for cryptographic algorithms using Yara...")
    yara_result = functions.yara_check_crypto(filename)
    if yara_result:
        for item in yara_result:
            print("\t{}".format(item))
        print(colored("\n\tFound {} suspicious cryptographic algorithms".format(len(yara_result)), "yellow"))
    else:
        print(colored("\n\tNo cryptographic algorithms found", "green"))

    # check for malware packers
    print("\n[*] Checking for malware packers using Yara...")
    yara_result = functions.yara_check_is_packed(filename)
    if yara_result:
        for item in yara_result:
            print("\t{}".format(item))
        print(colored("\n\tFound {} possible packer(s)".format(len(yara_result)), "yellow"))
    else:
        print(colored("\n\tNo malware packers found", "green"))

    # check for anti-debug/anti-virtualization functions
    print("\n[*] Checking for anti-debug and anti-virtualization functions using Yara...")
    yara_result = functions.yara_check_anti_virtual(filename)
    if yara_result:
        for item in yara_result:
            print("\t{}".format(item))

        print(colored("\n\tFound {} suspicious anti-debug/anti-virtualization functions".format(len(yara_result)), "yellow"))
    else:
        print(colored("\n\tNo anti-debug/anti-virtualization functions found", "green"))


def main():
    """
    The main program module for static analyzer.
    :return: None
    """
    # parse command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("-f", "--filename", type=str, required=True, help="executable filename to analyze")
    parser.add_argument("-v", "--verbose", dest="verbosity", action="count", default=0,
                        help="verbosity level between 0-4 (CRITICAL=0, ERROR=1, WARN=2, INFO=3, "
                             "DEBUG=4)")
    args = parser.parse_args()

    # set up logging
    log_levels = {0: logging.CRITICAL, 1: logging.ERROR, 2: logging.WARN, 3: logging.INFO, 4: logging.DEBUG}
    logging.basicConfig(level=log_levels[args.verbosity])

    # initialize colorama
    init()

    # gather important file properties
    get_file_properties(args.filename)

    # check for suspicious activity
    check_suspicious_activity(args.filename)

    # check for anti-virtualization features
    check_anti_virtual(args.filename)

    # check for suspicious activity using Yara
    yara_checks(args.filename)


if __name__ == "__main__":
    main()
