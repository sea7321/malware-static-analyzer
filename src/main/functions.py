"""
File: functions.py
Description: Functions that are used within static_analyzer.py
Author: Savannah Alfaro, sea2985@rit.edu
"""

# Standard Imports
import datetime
import hashlib
import os

# Third-Party Imports
import pefile
import peutils
import yara


def get_file_path(filename):
    """
    Retrieves the filepath of the file.
    :param filename: the portable executable filename
    :return: (str) the filepath
    """
    return os.path.abspath(filename)


def get_file_creation_date(filename):
    """
    Retrieves the file's creation date.
    :param filename: the portable executable filename
    :return: (str) the file creation date
    """
    return datetime.datetime.fromtimestamp(os.path.getctime(filename)).strftime("%m-%d-%Y %H:%M:%S")


def get_file_modification_date(filename):
    """
    Retrieves the file's modification date.
    :param filename: the portable executable filename
    :return: (str) the file modification date
    """
    return datetime.datetime.fromtimestamp(os.path.getmtime(filename)).strftime("%m-%d-%Y %H:%M:%S")


def get_file_size(filename):
    """
    Retrieves the file's size.
    :param filename: the portable executable filename
    :return: (int) the file size
    """
    return os.path.getsize(filename)


def get_md5_hash(filename):
    """
    Returns the md5 hash of the file.
    :param filename: the portable executable filename
    :return: md5 hash of file
    """
    return hashlib.md5(filename.encode('utf-8')).hexdigest()


def get_sha1_hash(filename):
    """
    Returns the sha1 hash of the file.
    :param filename: the portable executable filename
    :return: sha1 hash of file
    """
    return hashlib.sha1(filename.encode('utf-8')).hexdigest()


def get_sha256_hash(filename):
    """
    Returns the sha256 hash of the file.
    :param filename: the portable executable filename
    :return: sha256 hash of file
    """
    return hashlib.sha256(filename.encode('utf-8')).hexdigest()


#
# Suspicious Activity Functions
#
def get_dll_functions(filename):
    """
    Returns a list of all DLL functions found within the file.
    :param filename: the portable executable filename
    :return: (str[]) list of DLL functions
    """
    # variables
    functions = list()

    # gather all DLL functions
    try:
        pe = pefile.PE(filename)
        if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                functions.append(entry.dll.decode('utf-8'))
    except Exception:
        raise Exception("Error listing imported DLL functions within {}".format(filename))

    return functions


def get_function_calls(filename):
    """
    Returns a tuple of function calls and suspicious function calls that were flagged.
    :param filename: the portable executable filename
    :return: (str[], str[]) tuple of list of function calls and suspicious function calls
    """
    # variables
    suspicious_functions = ['RegSetValueEx', 'RegCreateKeyEx', 'RegEnumKeyEx', 'RegQueryValueEx', 'RegOpenKeyEx',
                            'RegCloseKey', 'RegEnumValue', 'CreateProcess', 'GetCurrentProcess', 'GetCurrentProcessID',
                            'CreateThread', 'SetThreadPriority', 'GetThreadPriority', 'GetProcessTimes', 'ExitProcess',
                            'GetFileVersionInfo', 'GetFileVersionInfoSize', 'GetSystemMetrics', 'GetSystemInfo',
                            'GetNativeSystemInfo', 'QueryPerformanceCounter', 'DeleteFile', 'GetFileType', 'MoveFile',
                            'GetFileAttributes', 'CopyFile', 'FindFirstFileEx', 'GetFileSize', 'ReadFile',
                            'EnableWindow', 'GetAsyncKeyState', 'CryptDeriveKey', 'CryptEncrypt', 'CryptDecrypt',
                            'CryptCreateHash', 'CryptHashData', 'HttpQueryInfo', 'HttpSendRequestEx', 'HttpEndRequest',
                            'HttpOpenRequest', 'InternetConnectA', 'InternetGetConnectedState', 'InternetSetOptionA',
                            'InternetWriteFile', 'InternetCrackUrlA', 'InternetSetStatusCallbackA', 'IsDebuggerPresent',
                            'CheckRemoteDebuggerPresent']
    function_calls = list()
    suspicious_function_calls = list()

    # gather all function calls
    try:
        pe = pefile.PE(filename)
        if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                for function_call in entry.imports:
                    function_calls.append(
                        "{} at 0x{}".format(function_call.name.decode('utf-8'), function_call.address))

                    # check to see if the function is suspicious
                    if function_call.name.decode('utf-8') in suspicious_functions:
                        suspicious_function_calls.append("{} at 0x{}".format(function_call.name.decode('utf-8'),
                                                                             function_call.address))
    except Exception:
        raise Exception("Error listing function calls within {}".format(filename))

    return function_calls, suspicious_function_calls


#
# Anti-Virtualization Functions
#
def is_packed(filename):
    """
    Checks to see if the malware is packed using peutils.
    :param filename: the portable executable filename
    :return: (Boolean) if the malware is packed
    """
    # variables
    packed = False
    pe_instance = pefile.PE(filename)

    # check to see if the file is packed
    if peutils.is_probably_packed(pe_instance):
        packed = True
    return packed


def get_anti_debug_functions(filename):
    """
    Checks to see if there are anti-debug functions within the file.
    :param filename: the portable executable filename
    :return: (str[]) the list of anti-debug functions found
    """
    # variables
    anti_debug_functions = ['IsDebuggerPresent', 'CheckRemoteDebuggerPresent']
    functions = list()

    # gather all function calls
    try:
        pe = pefile.PE(filename)
        if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                for function in entry.imports:

                    # check to see if the function has anti-debug functions
                    if function.name in anti_debug_functions:
                        functions.append("{} at 0x{}".format(function.name, function.address))
        else:
            raise Exception("No 'DIRECTORY_ENTRY_IMPORT' section file {}".format(filename))
    except Exception:
        raise Exception("Error while checking for anti-debug functions in {}".format(filename))

    return functions


#
# Yara Checks
#
def yara_check_crypto(filename):
    """
    Checks for cryptographic algorithms within the file using Yara rules.
    :param filename: the portable executable filename
    :return: (str[]) the Yara matches found
    """
    yara_rule_file = "./yara_rules/crypto_signatures.yar"
    rule = yara.compile(yara_rule_file)
    return rule.match(filename)


def yara_check_is_packed(filename):
    """
    Checks for malware packers within the file using Yara rules.
    :param filename: the portable executable filename
    :return: (str[]) the Yara matches found
    """
    yara_rule_file = "./yara_rules/packer.yar"
    rule = yara.compile(yara_rule_file)
    return rule.match(filename)


def yara_check_anti_virtual(filename):
    """
    Checks for anti-debug and anti-virtualization functions
    within the file using Yara rules.
    :param filename: the portable executable filename
    :return: (str[]) the Yara matches found
    """
    yara_rule_file = "./yara_rules/antidebug_antivm.yar"
    rule = yara.compile(yara_rule_file)
    return rule.match(filename)
